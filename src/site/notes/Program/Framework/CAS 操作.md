---
{"dg-publish":true,"permalink":"/Program/Framework/CAS 操作/","noteIcon":"","created":"2024-08-13T13:51:56.174+08:00"}
---

CAS（Compare-And-Swap，比较并交换）是一种用于实现同步的原子操作。它在多线程编程中非常重要，因为它允许在没有锁的情况下实现线程安全的操作。
### CAS 操作的基本原理
CAS 操作涉及三个操作数：
1. **内存位置（V）**：这是需要更新的变量的内存地址。
2. **预期值（A）**：这是你期望当前内存位置持有的值。
3. **新值（B）**：这是你希望写入内存位置的新值。

CAS 操作的逻辑如下：
- **如果** 内存位置 V 的当前值等于预期值 A，**那么** 将内存位置的值更新为新值 B，并返回 true，表示操作成功。
- **否则**，不做任何操作并返回 false，表示操作失败。

### 示例
假设有一个变量 `V`，它的当前值是 `5`，你希望将它更新为 `10`，但前提是你认为它的值仍然是 `5`。你执行以下操作：

- CAS(V, 5, 10)

如果 `V` 的当前值确实是 `5`，那么 `V` 将被更新为 `10`。如果在执行 CAS 操作之前，另一个线程已经将 `V` 改为了 `7`，那么 CAS 操作将失败，并且 `V` 的值保持为 `7`。

### 为什么 CAS 是原子的？

CAS 操作在硬件级别是原子操作，这意味着它在执行过程中不会被其他线程中断。硬件（例如现代的 CPU）提供了专门的指令来确保 CAS 操作的原子性。例如，在 x86 架构上，CAS 操作可以通过 `CMPXCHG` 指令来实现。

### CAS 的优点
- **无锁同步**：CAS 允许在多线程环境中进行无锁的同步，避免了使用传统锁（如互斥锁）时的性能开销和线程竞争。
- **高性能**：由于避免了锁机制，CAS 在多线程环境下具有更高的性能和可扩展性，特别适合高并发场景。

### CAS 的缺点
- **ABA 问题**：CAS 可能面临所谓的 ABA 问题。即：假设一个变量的值从 A 变为 B，然后又变回 A，CAS 可能无法察觉到中间的变化。解决 ABA 问题的一种常见方法是使用版本号或时间戳来标记每次的更改。
- **自旋问题**：如果 CAS 操作持续失败（例如，由于其他线程不断地更新值），它可能会陷入长时间的自旋（反复尝试），从而浪费 CPU 资源。

### 在 Java 中的应用
在 Java 中，CAS 操作由 `sun.misc.Unsafe` 类提供的 `compareAndSwapXXX` 方法实现，并且在 Java 的并发包（如 `java.util.concurrent`）中大量使用。例如，`AtomicInteger`、`AtomicLong` 等类都是基于 CAS 实现的。

通过 CAS 操作，Java 提供了一种高效的方式来实现线程安全的原子操作，从而在多线程环境中避免了复杂的锁机制。